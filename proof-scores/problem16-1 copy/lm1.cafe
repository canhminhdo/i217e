in ../../pgm.cafe

-- ----------------------------------------------------------------------------
-- LEMMA1: \forall L1 L2 \in NAT: ((size(L1) > 0) and (size(L2) > 0)) implies (min(L1 @ L2) = min(min(L1), min(L2))) .
-- [require] 
-- ----------------------------------------------------------------------------

select NATLIST
--> PROOF: LEMMA1
--> base case
open NATLIST .
    ops l1 l2 : -> NatList .
    red ((size(nil) > 0) and (size(l2) > 0)) implies (min(nil @ l2) = min(min(nil), min(l2))) .
close

--> induction case
--> case 1
open NATLIST .
    ops l1 l2 : -> NatList .
        ops x y : -> PNat .
    
    -- induction case for l1
        -- base case for l2
    red ((size(x | l1) > 0) and (size(nil) > 0)) implies (min((x | l1) @ nil) = min(min(x | l1), min(nil))) .
close

--> case 2
open NATLIST .
    ops l1 l2 : -> NatList .
    ops x y : -> PNat .

    vars L1 L2 : NatList .
    vars I J : PNat .
    
    -- use PROBLEM 5 - LEMMA1
    eq size(L1 @ L2) = size(L1) + size(L2) .
    -- use LEMMA ???
    eq ((I + s(J)) > 0) = true .
    eq min(l1 @ (y | l2)) = min((y | l2) @ l1) .
    -- induction case for l1
        -- induction case for l2
    red ((size(x | l1) > 0) and (size(y | l2) > 0)) implies (min((x | l1) @ (y | l2)) = min(min(x | l1), min(y | l2))) .
close

eof

((if (x < min((l1 @ (y | l2)))) then x else min((l1 @ (y | l2))) fi) = (if ((if (size(l1) > 0) then (if (x < min(l1)) then x else min(l1) fi) else x fi) < (if (size(l2) > 0) then (if (y < min(l2)) then y else min(l2) fi) else y fi)) then (if (size(l1) > 0) then (if (x < min(l1)) then x else min(l1) fi) else x fi) else (if (size(l2) > 0) then (if (y < min(l2)) then y else min(l2) fi) else y fi) fi)):Bool

--> case 2.1.1
open PNAT .
    ops i j : -> PNat .    
    
    -- case splitting
    eq (i < j) = true .
    eq (j < i) = true .
    -- induction case for i
        -- induction case for j
    red 
        (((i < j)) implies (not (j < i))) implies
        ((s(i) < s(j)) implies (not (s(j) < s(i)))) .
close

--> case 2.1.2
open PNAT .
    ops i j : -> PNat .    
    
    -- case splitting
    eq (i < j) = true .
    eq (j < i) = false .
    -- induction case for i
        -- induction case for j
    red ((s(i) < s(j)) implies (not (s(j) < s(i)))) .
close

--> case 2.2
open PNAT .
    ops i j : -> PNat .    
    
    -- case splitting
    eq (i < j) = false .
    -- induction case for i
        -- induction case for j
    red ((s(i) < s(j)) implies (not (s(j) < s(i)))) .
close
