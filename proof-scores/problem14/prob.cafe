in ../../pgm.cafe

-- ----------------------------------------------------------------------------
-- PROBLEM14: \forall L \in NatList: max(L) = max(rev(L)) .
-- [require] LEMMA1, LEMMA2, LEMMA3, PROBLEM13, PROBLEM13 - LEMMA1
-- ----------------------------------------------------------------------------

select NATLIST
--> PROOF: PROBLEM14
--> base case
open NATLIST .
    op nil : -> PNat .

    red max(nil) = max(rev(nil)) .
close

--> induction case
--> case 1.1.1
open NATLIST .
    op x : -> PNat .
    op l : -> NatList .
    
    vars L1 L2 : NatList .
    
    -- induction hypothesis
    eq [IH] : max(l) = max(rev(l)) .
    -- case splitting
    eq (x > max(rev(l))) = true .
    eq (x > 0) = true .
    eq (max(rev(l)) > x) = false .
    -- use PROBLEM13 as a lemma
    eq max(L1 @ L2) = max(max(L1), max(L2)) .
    -- induction case
    red max(x | l) = max(rev(x | l)) .
close

--> case 1.1.2
open NATLIST .
    op x : -> PNat .
    op l : -> NatList .
    
    vars L1 L2 : NatList .
    
    -- induction hypothesis
    eq [IH] : max(l) = max(rev(l)) .
    -- case splitting
    eq (x > max(rev(l))) = true .
    eq (x > 0) = true .
    eq (max(rev(l)) > x) = true .
    -- use PROBLEM13 as a lemma
    eq max(L1 @ L2) = max(max(L1), max(L2)) .
    -- induction case: using LEMMA1 as antecedent
    red
        ((x > max(rev(l))) implies (not (max(rev(l)) > x))) implies
        max(x | l) = max(rev(x | l)) .
close

--> case 1.2.1
open NATLIST .
    op x : -> PNat .
    op l : -> NatList .
    
    vars L1 L2 : NatList .
    
    -- induction hypothesis
    eq [IH] : max(l) = max(rev(l)) .
    -- case splitting
    eq (x > max(rev(l))) = true .
    eq (x > 0) = false .
    eq (max(rev(l)) > 0) = true .
    -- use PROBLEM13 as a lemma
    eq max(L1 @ L2) = max(max(L1), max(L2)) .
    -- induction case: using PROBLEM13 - LEMMA1 as antecedent
    red 
        (((x > max(rev(l))) and (max(rev(l)) > 0)) implies (x > 0)) implies
        (max(x | l) = max(rev(x | l))) .
close

--> case 1.2.2.1
open NATLIST .
    op x : -> PNat .
    op l : -> NatList .
    
    vars L1 L2 : NatList .
    
    -- induction hypothesis
    eq [IH] : max(l) = max(rev(l)) .
    -- case splitting
    eq (x > max(rev(l))) = true .
    eq (x > 0) = false .
    eq (max(rev(l)) > 0) = false .
    eq (x = 0) = true .
    -- use PROBLEM13 as a lemma
    eq max(L1 @ L2) = max(max(L1), max(L2)) .
    -- induction case
    red 
        (max(x | l) = max(rev(x | l))) .
close

--> case 1.2.2.2
open NATLIST .
    op x : -> PNat .
    op l : -> NatList .
    
    vars L1 L2 : NatList .
    
    -- induction hypothesis
    eq [IH] : max(l) = max(rev(l)) .
    -- case splitting
    eq (x > max(rev(l))) = true .
    eq (x > 0) = false .
    eq (max(rev(l)) > 0) = false .
    eq (x = 0) = false .
    -- use PROBLEM13 as a lemma
    eq max(L1 @ L2) = max(max(L1), max(L2)) .
    -- induction case: using LEMMA2 as antecedent
    red 
        ((not (x > 0)) implies (x = 0)) implies
        (max(x | l) = max(rev(x | l))) .
close

--> case 2.1.1
open NATLIST .
    op x : -> PNat .
    op l : -> NatList .
    
    vars L1 L2 : NatList .
    
    -- induction hypothesis
    eq [IH] : max(l) = max(rev(l)) .
    -- case splitting
    eq (x > max(rev(l))) = false .
    eq (x > 0) = true .
    eq (max(rev(l)) > x) = true .
    -- use PROBLEM13 as a lemma
    eq max(L1 @ L2) = max(max(L1), max(L2)) .
    -- induction case
    red max(x | l) = max(rev(x | l)) .
close

--> case 2.1.2.1
open NATLIST .
    op x : -> PNat .
    op l : -> NatList .
    
    vars L1 L2 : NatList .
    
    -- induction hypothesis
    eq [IH] : max(l) = max(rev(l)) .
    -- case splitting
    eq (x > max(rev(l))) = false .
    eq (x > 0) = true .
    eq (max(rev(l)) > x) = false .
    eq (max(rev(l)) = x) = true .
    -- use PROBLEM13 as a lemma
    eq max(L1 @ L2) = max(max(L1), max(L2)) .
    -- induction case
    red 
        max(x | l) = max(rev(x | l)) .
close

--> case 2.1.2.2
open NATLIST .
    op x : -> PNat .
    op l : -> NatList .
    
    vars L1 L2 : NatList .
    
    -- induction hypothesis
    eq [IH] : max(l) = max(rev(l)) .
    -- case splitting
    eq (x > max(rev(l))) = false .
    eq (x > 0) = true .
    eq (max(rev(l)) > x) = false .
    eq (max(rev(l)) = x) = false .
    -- use PROBLEM13 as a lemma
    eq max(L1 @ L2) = max(max(L1), max(L2)) .
    -- induction case: using LEMMA3 as antecedent
    red 
        (((not (x > max(rev(l)))) and (not (max(rev(l)) > x))) implies (x = max(rev(l)))) implies
        (max(x | l) = max(rev(x | l))) .
close

--> case 2.2.1
open NATLIST .
    op x : -> PNat .
    op l : -> NatList .
    
    vars L1 L2 : NatList .
    
    -- induction hypothesis
    eq [IH] : max(l) = max(rev(l)) .
    -- case splitting
    eq (x > max(rev(l))) = false .
    eq (x > 0) = false .
    eq (max(rev(l)) > 0) = true .
    -- use PROBLEM13 as a lemma
    eq max(L1 @ L2) = max(max(L1), max(L2)) .
    -- induction case
    red max(x | l) = max(rev(x | l)) .
close

--> case 2.2.2.1
open NATLIST .
    op x : -> PNat .
    op l : -> NatList .
    
    vars L1 L2 : NatList .
    
    -- induction hypothesis
    eq [IH] : max(l) = max(rev(l)) .
    -- case splitting
    eq (x > max(rev(l))) = false .
    eq (x > 0) = false .
    eq (max(rev(l)) > 0) = false .
    eq (max(rev(l)) = 0) = true .
    -- use PROBLEM13 as a lemma
    eq max(L1 @ L2) = max(max(L1), max(L2)) .
    -- induction case
    red max(x | l) = max(rev(x | l)) .
close

--> case 2.2.2.2
open NATLIST .
    op x : -> PNat .
    op l : -> NatList .
    
    vars L1 L2 : NatList .
    
    -- induction hypothesis
    eq [IH] : max(l) = max(rev(l)) .
    -- case splitting
    eq (x > max(rev(l))) = false .
    eq (x > 0) = false .
    eq (max(rev(l)) > 0) = false .
    eq (max(rev(l)) = 0) = false .
    -- use PROBLEM13 as a lemma
    eq max(L1 @ L2) = max(max(L1), max(L2)) .
    -- induction case: using LEMMA2 as antecedent
    red
        ((not (max(rev(l)) > 0)) implies (max(rev(l)) = 0)) implies
        (max(x | l) = max(rev(x | l))) .
close