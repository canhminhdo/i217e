mod! PNAT principal-sort PNat {
  [PNat]
  op 0 : -> PNat {constr} .
  op s : PNat -> PNat {constr} .
  op _+_ : PNat PNat -> PNat .
  op _*_ : PNat PNat -> PNat .
  op fact : PNat -> PNat .
  vars X Y Z : PNat . 
  eq (0 = s(Y)) = false .
  eq (s(X) = s(Y)) = (X = Y) .
  eq [+1] : 0 + Y = Y .
  eq [+2] : s(X) + Y = s(X + Y) .
  eq [*1] : 0 * Y = 0 .
  eq [*2] : s(X) * Y = (X * Y) + Y .
  eq [fact1] : fact(0) = s(0) .
  eq [fact2] : fact(s(X)) = s(X) * fact(X) .
}

mod! LIST (E :: TRIV) {
  [List]
  op nil : -> List {constr}
  op _|_ : Elt.E List -> List {constr} .
  op _@_ : List List -> List .
  op rev : List -> List .
  vars E E2 : Elt.E .
  vars L1 L2 L3 : List .
  eq (nil = E | L1) = false .
  eq (E | L1 = E2 | L2) = (E = E2) and (L1 = L2) .
  eq [@1] : nil @ L2 = L2 .
  eq [@2] : (E | L1) @ L2 = E | (L1 @ L2) .
  eq [rev1] : rev(nil) = nil .
  eq [rev2] : rev(E | L1) = rev(L1) @ (E | nil) .
}

mod! NATLIST {
  pr(LIST(PNAT) * {sort List -> NatList})
  op mkl1 : PNat -> NatList .
  op mkl2 : PNat -> NatList .
  op smkl2 : PNat NatList -> NatList .
  op fold* : NatList -> PNat .
  op size : NatList -> PNat .
  var X : PNat .
  var L : NatList  .
  eq [mkl1-1] : mkl1(0) = nil .
  eq [mkl1-2] : mkl1(s(X)) = s(X) | mkl1(X) .
  eq [mkl2] : mkl2(X) = smkl2(X,nil) .
  eq [smkl2-1] : smkl2(0,L) = L .
  eq [smkl2-2] : smkl2(s(X),L) = smkl2(X,s(X) | L) .
  eq [fold*-1] : fold*(nil) = s(0) .
  eq [fold*-2] : fold*(X | L) = X * fold*(L) .
  eq [size-1] : size(nil) = 0 .
  eq [size-2] : size(X | L) = size(L) + s(0) .
}